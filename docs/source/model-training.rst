5. Model Training
==========
AI and ML are iterative methods that uncover valuable information and insights that are not clearly apparent from within data. The process helps unlock the data’s full potential to deliver business value decision support and automation. AI-ML methods use models that training algorithms build from relevant data to fulfil the desired tasks and objectives, and, therefore, data are at the core of AI-ML, underpinning its operation and success. Without relevant data of the required quantity, quality and frequency, AI-ML would yield inaccurate and potentially unusable output. It is important to remark that despite the fact that scientists worldwide are developing more dynamic and adaptive methods, the reality remains that different business needs are likely to require the use of different AI and ML methods depending on the user requirements. More importantly, the models built by the algorithms need specific data to address the requirements at hand. Similar to the human brain, if we would like an algorithm to predict traffic jams on a particular road, then a sufficient quantity of relevant historical data about previous traffic jams, dates, times and weather conditions will significantly help in making more accurate predictions. However, the data required to predict a traffic jam are different from the data required to predict a football match outcome, even if we use the same methods. 

5.1 Training Algorithms
---------
In this section, we introduce the notion of training algorithms and provide an overview of the gradient descent (GD) approach used by algorithms that train supervised ML models. This discussion will require some simple mathematical notation. For simplicity, we will refer to an ML model for classification, defined by a function :math:`F_w : DS → C`from the input data space (DS) to a finite set of classes or categories (C). As an example, the inputs to :math:`F_w` could be sensor readings about the rotatory engines presented in Section 1, and the outputs could be the (IMMINENT and NOT-IMMINENT) labels about failure of the running example of Section 1. 

Here we use the mathematical notation :math:`F_w` to designate the ML model map-ping inputs to one of the categories. This notation is useful because the subscript in :math:`F_w` highlights the array w of the ML classifier’s internal parameters, often called its weights. Of course, the data-flow structure of the computation performed by :math:`F_w` depends on the specific ML model used, but the result of the computation depends on the values of the weights w. For example, using a multi-stage neural network (NN) as our classifier, the output of each stage of the network is computed as a weighted combination of the outputs coming from the previous stage, called activations [#f7]_ . Activations to the first stage coincide with the one-hot encoded inputs discussed in the previous sections. 

In essence, model training algorithms are the algorithms that adjust the weights w of the model so that :math:`F_w` coincides over S with a target function :math:`f: DS → C`, which expresses the correct classification of all points in the input space. 

In terms of our notation, the training set mentioned in Chapter 1 is a set S of sensor inputs for which the values of :math:`f: DS → C` (i.e., the right IMMINENT and NOT-IMMINENT labels), are known. In the remainder of the section, we outline how training algorithms work. 

.. rubric:: Footnotes

.. [#f7] The reader interested in a general introduction to NNs can consult Michael Nielsen’s free online book (http://neuralnetworksanddeeplearning.com/). 

5.1.1 Gradient Descent Training
~~~~~~~~~~~~
GD is a popular family of iterative algorithms for training supervised ML models like neural networks. GD is based on a simple mathematical notion, which can be expressed as follows: in any smoothly changing (in mathematical terms, differentiable) function :math:`f`, a maximum or minimum is always where the function flattens out (i.e., where the function graph’s slope is zero). Calculus highlights that a function of a single variable :math:`f(x)` flattens out where its derivative :math:`f^i`, expressing its slope, is zero [#f8]_ . For multidimensional functions :math:`f(v)`, where v is an array of variables, we can look for points where the gradient :math:`\nabla f_w`, the multidimensional analogy of the derivative, becomes zero. The basic version of GD works as follows: at each step, the GD algorithm perturbs the ML model’s weights vector :math:`w`, applies the model :math:`F_w` to one or more elements of the training set S and computes the model’s current classification error :math:`E_w` (i.e., the difference between the outputs of :math:`F_w` on those elements and the elements’ labels). Then, GD uses the error’s variations across these input elements to numerically estimate :math:`\nabla E_w` and updates w based on it. The model’s classification error :math:`E_w` can be computed as the linear (L1) or quadratic (L2) sum of the differences between :math:`F_w` outputs and the ground truths available as the known labels of the elements of the training :math:`S`, in our notation :math:`f(S)`.

Informally, it can be said that by this procedure, the GD tries to 'drive' :math:`F_w` toward smaller values of the error gradient, progressively reducing :math:`E_w`. The final goal of GD is to find the point where the :math:`\nabla E_w` gradient is zero, corresponding to the vector w that minimises :math:`E_w` on the training set S.

.. rubric:: Footnotes

.. [#f8] The reader interested in a general introduction to NNs can consult Michael Nielsen’s free online book (http://neuralnetworksanddeeplearning.com/). 

5.1.2 A Closer Look 
~~~~~~~~~~~~
While the above informal description can be sufficient for a general understanding of GD-based model training, from a more mathematically-aware data manager's point of view, it is also useful to take a closer look at the computation performed by the software implementations of GD to estimate :math:`\nabla E_w`. This requires just a little bit of algebra. At each computation step, given the current weights vector :math:`w`, the GD algorithm generates three nearby vectors :math:`w_1, w_2, w_3`. This way, computing :math:`E_w(w)E_w(w_i)` for :math:`i \in \{1,2,3\}` gives approximately the directional derivative of the error :math:`E_w` at :math:`w` in the direction :math:`w_i`. The derivative is indeed the projection of the gradient :math:`\nabla E_w(w)` in the direction of :math:`w - w_i`, or :math:`\frac{\nabla E_w w}{w_i}`. Now, let us assume the following approximation holds:

:math:`E_w(w)E_w(w_i) = \nabla E_w(w)(w-w_i). \quad (2)`

As the error :math:`E_w` is itself a scalar, i.e. a single number rather than an array, this is a system of three linear scalar equations in three unknowns (the components of :math:`\nabla E_w`). Basic algebra tells us that, if the three vectors :math:`w w_i` are orthogonal, this linear system has a unique solution, so it can be solved numerically by the GD algorithm to obtain the gradient’s components. 

This computation requires calculating :math:`E_w`, a computation that can in principle be done using a single element of :math:`S`. However, the different implementations of the GD algorithm used in ML software libraries differ from one another in terms of the number of elements of the training set :math:`S` that are used at each step to compute :math:`E_w`. As intuition suggests, the higher this number, the higher are both the *fidelity* of the GD algorithm in following the error gradient and - unfortunately - its overall computation time.

- **Stochastic Gradient Descent (SGD)** is a variation of the GD approach that computes :math:`E_w`, estimates :math:`\nabla E_w` and updates :math:`F_w` using a single random entry :math:`e` of :math:`S`. Frequent updates of :math:`F_w` introduce a noise-like "jerky" effect on :math:`E_w`, but allow for continuously monitoring the ML model's performance.

- **Batch Gradient Descent (BGD)** computes error :math:`E_w` (and estimates :math:`\nabla E_w`) for each :math:`e \in S`, but only updates :math:`F_w` after having scanned all of :math:`S` (i.e. once for each *epoch*). Our intuition suggests that BGD's lower frequency of updates results in less sign variations in :math:`E_w`. For our purposes, it is worth remarking that - due to the granularity of :math:`\nabla E_w` estimates - BGD is usually implemented in such a way that all the training set S needs to be in memory at the same time.

- **Mini-Batch Gradient Descent (MBGD)** splits randomly :math:`f` into subsets (the "small batches"), which are used to compute :math:`E_w`, estimate :math:`\nabla E_w` and update :math:`F_w` accordingly. In this case what is used to estimate :math:`\nabla E_w` is actually an aggregation :math:`h_{MB}(E_w)`, where :math:`MB` is the mini-batch. Instead of computing the aggregation :math:`h` as a sum of errors over the mini-batch, it is common practice of implementations to take the average, to keep :math:`E_w` variance under control.

Today, the MBGD variant of GD has become increasingly popular and widely used for training "deep" ML models. Its update frequency is higher than the one of plain BGD; also, its batch size (one of the algorithm's *hyper-parameters*) acts as a control over the learning process. Small batch size values may give faster convergence at the cost of introducing noise in the training process. Large values give a learning process that converges slowly but provides accurate estimates of :math:`E_w` gradient.


5.1.3 Federated Learning
~~~~~~~~~
The variations of the GD training algorithm described above are all centralized: all the training set S is in a single place and all of it is considered for extracting batched for the gradient’s computation. In principle, the GD algorithm can be made parallel by using multiple batches B at the same time, and training the the ML model on multiple processors. Parallel implementations of GD should not be confused with federated learning, which is targeted to addressing data privacy and security as well as data access rights. 

Federated learning is based on a different notion: multiple nodes hold each a part of the training data S, without sharing it. In terms of our notation, the training set S is partitioned into multiple local training sets :math:`S1,....Sn` held by their respective owners, without explicitly exchanging data samples. The general principle of federated learning consists in training local models on local data samples and exchanging the models’ internal parameters (e.g. their weights) at some frequency, in order to generate a global ML model shared by all nodes. In federated learning, the local training set’s parts S1,....Sn are typically heterogeneous and their sizes may span several orders of magnitude. Moreover, the partners involved in federated learning may be unreliable as they are subject to more failures or drop out. There are two major families of federated learning algorithms. 

*	Centralized federated learning In centralized federated learning algorithms, a central coordinating node orchestrates the different steps of the training algorithm and coordinates the other participating nodes during the algorithm’s execution. The coordinator is responsible for the nodes selection at the start of the training process and for aggregating of the received model updates. 
*	Decentralized federated learning In decentralized federated learning algorithms, participating nodes collaborate in a peer-to-peer fashion to obtain a global ML model. This organization aims to prevent single-point failure. 


5.2 Automatic Organisation of Data
---------
AI/ML models help to better understand data and uncover patterns and information hidden within it, to provide additional valuable insight. Hence, it is no surprise that one of the key challenges we first encounter when dealing with data, both structured (numerical or categorical data) and unstructured (text data), is the need to group together similar objects that the data represents. These groups will contain the objects that are more similar to each other than those in other groups based on some attributes of the objects. In many cases, the user does not have a view of the groups themselves or indeed the number of distinct groups. Hence, clustering the objects that the data represents provides an initial understanding of the data, that will help with further analysis. For example, let us consider a call centre for a retail bank, that receives a large volume of calls from customers. If the bank’s call centre manager is planning training topics for his employees, then grouping the calls together in groups based on similarity will show the topics that are generating calls, and the volume of calls associated with each topic. This insight will help the bank focus the training on areas of importance to the customers, and help to provide a better service. This kind of grouping or clustering could also uncover topics that the manager may not have previously anticipated. In AI/ML, a clustering algorithm is a technique or method used to automatically group the objects that the data represents into different clusters based on their similarities. This is known as unsupervised learning. 

5.3 Generating New Data
---------
It is possible to generate brand new data using certain AI techniques. These techniques are able to produce augmented data, i.e. synthetic training data of any size, targeting applications where requirements and results depend on greater quantity. You can use synthetic data when you are required to train an ML model requiring a larger amount of data than what you have, or to cover a different set of data points that have been too difficult to obtain by normal means. Synthetic data can be produced from any type of data including numbers, text, images and sounds. Other than for training purposes, new data requiring creative thinking can be produced in this way. Creating new art pieces, music or writings is possible using ML models that can learn the patterns from data made from the same creator. 
